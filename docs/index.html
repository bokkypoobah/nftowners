<!DOCTYPE html>
<html lang="en">
  <head>
    <title>NFT Owners</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="NFT Owners (c) Bok Consulting Pty Ltd 2022" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/app.css" />
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.6.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="js/dexie.js"></script>
    <script src="globals.js"></script>
    <script src="deploymentData.js"></script>
    <script src="txparser.js"></script>

    <link rel="apple-touch-icon" sizes="57x57" href="images/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="images/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="images/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="images/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="images/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="images/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="images/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="images/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="manifest" href="images/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="images/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/ZombieBaby_001_gp2_3871_8601_10786.gif" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <em v-b-popover.hover.bottom="'gm gm gm'">NFT Owners</em>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <!-- <b-avatar v-if="coinbase && coinbase != ensOrAddress(coinbase)" rounded variant="light" size="2.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensOrAddress(coinbase)" v-b-popover.hover="'Your ENS avatar if set'"></b-avatar>
            <b-button size="sm" variant="primary" class="ml-1" @click="processIt('connect')" v-b-popover.hover.bottom="'Click to update wallet'">{{ coinbase ? ensOrAddress(coinbase, 32) : 'Connect' }}</b-button> -->
          </b-navbar-nav>
        </b-navbar>

        <b-card no-body class="p-0 mt-0" style="min-height: 666px;">
          <b-alert v-if="false" size="sm" dismissible variant="warning" show class="m-1 my-0">
            Warning: This is experimental unaudited software. Revoke permissions when not required, at this early stage.
          </b-alert>
          <b-card class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="!coinbase">
            <b-card-text>
              Please install the MetaMask extension, connect to the Ethereum mainnet and refresh this page. Then click the [Connect] button on the top right.
            </b-card-text>
          </b-card>

          <b-card class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <template #header>
              Collections
            </template>
            <div class="d-flex flex-wrap m-0 p-0">
              <div v-if="false" class="mt-0 pr-1">
                <b-form-input type="text" size="sm" v-model.trim="settings.collections.filter" @change="settingsUpdated" debounce="600" v-b-popover.hover.top="'Collection name filter'" placeholder="🔍 collection" style="min-width: 12.0rem;"></b-form-input>
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" :disabled="sync.section != null" @click="processIt('syncCollections')" variant="primary" v-b-popover.hover.top="'Sync selected or all collections'">Sync</b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" :pressed.sync="settings.addCollection" @click="settingsUpdated" variant="link" v-b-popover.hover.top="'Add new collection'"><span v-if="settings.addCollection"><b-icon-plus-square-fill shift-v="+1" font-scale="1.0"></b-icon-plus-square-fill></span><span v-else><b-icon-plus-square shift-v="+1" font-scale="1.0"></b-icon-plus-square></span></b-button>
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" :disabled="sync.section != null || Object.keys(selectedCollections).length == 0" @click="deleteCollections" variant="link" v-b-popover.hover="'Delete selected collections'"><b-icon-trash style="color: #ff0000;" shift-v="+1" font-scale="1.0"></b-icon-trash></b-button>
              </div>
              <!-- <div class="mt-0 pr-1">
                <b-button size="sm" :disabled="sync.section != null && searchCollections.filter != null && searchCollections.filter.length > 0" @click="doSearchCollections" variant="link" v-b-popover.hover.top="'Search for collection name'">Search</b-button>
              </div> -->
              <!-- <div class="mt-0 pr-1">
                <b-button size="sm" :disabled="sync.section != null || settings.mainCollection == null || settings.mainCollection.length == 0" @click="processIt('retrieveMainCollection')" variant="primary" v-b-popover.hover.top="'Retrieve main collection data'">Retrieve Main</b-button>
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" :disabled="sync.section != null || filteredSortedMainTable.length == 0" @click="processIt('retrieveSecondaryCollection')" variant="primary" v-b-popover.hover.top="'Retrieve secondary collection data'">Retrieve Secondary</b-button>
              </div> -->
              <!-- <div class="mt-0 pr-1">
                <b-form-input type="text" size="sm" v-model.trim="settings.addressTable.searchAddresses" @change="settingsUpdated" debounce="600" v-b-popover.hover.top="'Filter by partial address, name'" placeholder="🔍 address"></b-form-input>
              </div> -->
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-1" style="width: 200px;">
                <b-progress v-if="sync.section != null" height="1.5rem" :max="sync.total" show-progress :animated="sync.section != null" :variant="sync.section != null ? 'success' : 'secondary'" v-b-popover.hover.top="'Click the button on the right to stop. This process can be continued later'">
                  <b-progress-bar :value="sync.completed">
                    {{ sync.total == null ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                  </b-progress-bar>
                </b-progress>
              </div>
              <div class="ml-0 mt-1">
                <b-button v-if="sync.section != null" size="sm" @click="halt" variant="link" v-b-popover.hover.top="'Click to stop. It may take a few minutes to clean up. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <!-- <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pr-0">
                <b-button size="sm" :pressed.sync="settings.addAddresses" @click="settingsUpdated" variant="link" v-b-popover.hover.top="'Add addresses, tx hashes, Etherscan API key'"><span v-if="settings.addAddresses"><b-icon-plus-square-fill shift-v="+1" font-scale="1.0"></b-icon-plus-square-fill></span><span v-else><b-icon-plus-square shift-v="+1" font-scale="1.0"></b-icon-plus-square></span></b-button>
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" :pressed.sync="settings.editAddresses" @click="settingsUpdated" :variant="settings.editAddresses ? 'danger' : 'link'" v-b-popover.hover.top="settings.editAddresses ? 'End editing address attributes' : 'Edit address attributes'"><b-icon-pencil shift-v="+1" font-scale="1.0"></b-icon-pencil></b-button>
              </div> -->
              <!-- <div class="mt-0 flex-grow-1">
              </div> -->
              <!-- <div class="mt-0 pr-1">
                <b-button size="sm" @click="exportAddresses" variant="link">Export</b-button>
              </div> -->
              <!-- <div class="mt-0 flex-grow-1">
              </div> -->
              <div class="mt-0 pr-1">
                <b-form-select size="sm" v-model="settings.collections.sortOption" @change="settingsUpdated" :options="collectionsSortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
              </div>
              <div class="mt-0 pr-1">
                <font size="-2" v-b-popover.hover.top="'# txs'">{{ filteredSortedCollections.length }}</font>
              </div>
              <div class="mt-0 pr-1">
                <b-pagination size="sm" v-model="settings.collections.currentPage" @input="settingsUpdated" :total-rows="filteredSortedCollections.length" :per-page="settings.collections.pageSize" style="height: 0;"></b-pagination>
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.collections.pageSize" @change="settingsUpdated" :options="pageSizes" v-b-popover.hover.top="'Addresses page size'"></b-form-select>
              </div>
            </div>
            <!-- <b-card>
              {{ searchCollections.results }}
            </b-card> -->
            <b-card v-if="settings.addCollection" class="mx-5 mt-1 mb-0 p-0 border-1" no-body body-class="m-0 p-0" header-class="m-0 p-0">
              <b-card-header>
                Add Collection
              </b-card-header>
              <b-card-text>
                <div class="d-flex flex-wrap m-1 p-0">
                  <div class="mt-0 pr-1">
                    <b-form-input type="text" size="sm" v-model.trim="searchCollections.filter" @input="doSearchCollections" debounce="600" v-b-popover.hover.top="'Collection name filter'" placeholder="🔍 collection name" style="min-width: 12.0rem;"></b-form-input>
                  </div>
                </div>
                <b-table small fixed striped responsive hover :fields="searchCollectionsFields" :items="searchCollections.results" show-empty empty-html="Enter name fragment in the top left input field" head-variant="light" class="m-0">
                  <template #cell(action)="data">
                    <b-button v-if="!(data.item.contract in collections)" size="sm" @click="addCollection(data.item)" variant="primary">Add</b-button>
                    <b-button v-if="data.item.contract in collections" disabled size="sm" @click="addCollection(data.item)" variant="outline-primary">Added</b-button>
                  </template>
                  <template #cell(collection)="data">
                    <div class="d-flex flex-row">
                      <div>
                        <b-avatar rounded variant="light" size="3.0rem" :src="data.item.image">
                        </b-avatar>
                      </div>
                      <div class="ml-2">
                        {{ data.item.name }}
                        <br />
                        Volume: 1d {{ commify(data.item.volume["1day"]) + 'e' }}; 7d {{ commify(data.item.volume["7day"]) + 'e' }}; 30d {{ commify(data.item.volume["30day"]) + 'e' }}; allTime {{ commify(data.item.volume["allTime"]) + 'e' }}
                      </div>
                    </div>
                  </template>
                </b-table>
              </b-card-text>
            </b-card>

            <b-table small fixed striped responsive hover :fields="collectionsFields" :items="pagedFilteredSortedCollections" show-empty empty-html="Click [+] above to add new collections" head-variant="light" class="mx-0 my-1">
              <template #head(number)="data">
                <b-dropdown size="sm" variant="link" v-b-popover.hover="'Toggle selection'">
                  <template #button-content>
                    <b-icon-check-square shift-v="+1" font-scale="0.9"></b-icon-check-square>
                  </template>
                  <b-dropdown-item href="#" @click="toggleSelectedCollections(pagedFilteredSortedCollections)">Toggle selection for all addresses on this page</b-dropdown-item>
                  <b-dropdown-item href="#" @click="toggleSelectedCollections(filteredSortedCollections)">Toggle selection for all addresses on all pages</b-dropdown-item>
                  <b-dropdown-item href="#" @click="clearSelectedCollections()">Clear selection</b-dropdown-item>
                </b-dropdown>
              </template>
              <template #cell(number)="data">
                <b-form-checkbox size="sm" :checked="selectedCollections[data.item.contract] ? 1 : 0" value="1" @change="toggleSelectedCollections([data.item])">
                  {{ parseInt(data.index) + ((settings.collections.currentPage - 1) * settings.collections.pageSize) + 1 }}
                </b-form-checkbox>
              </template>
              <template #cell(collection)="data">
                <div class="d-flex flex-row">
                  <div>
                    <b-avatar rounded variant="light" size="3.0rem" :src="data.item.image">
                    </b-avatar>
                  </div>
                  <div class="ml-2">
                    {{ data.item.name }}
                    <br />
                    Volume: 1d {{ commify(data.item.volume["1day"]) + 'e' }}; 7d {{ commify(data.item.volume["7day"]) + 'e' }}; 30d {{ commify(data.item.volume["30day"]) + 'e' }}; allTime {{ commify(data.item.volume["allTime"]) + 'e' }}
                  </div>
                </div>
              </template>
            </b-table>
          </b-card>

          <b-card class="m-0 p-0 border-0" no-body body-class="m-1 p-0" header-class="m-0 p-2">
            <template #header>
              CrossTab
            </template>
            <div class="d-flex flex-wrap m-0 mt-1 p-0">
              <div class="mt-0 pr-1">
                <b-form-input type="text" size="sm" v-model.trim="settings.crossTab.filter" @change="settingsUpdated" debounce="600" v-b-popover.hover.top="'TODO: Filter by address/ENS'" placeholder="address fragment" style="min-width: 12.0rem;"></b-form-input>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pr-1">
                <b-form-select size="sm" v-model="settings.crossTab.sortOption" @change="settingsUpdated" :options="mainTableSortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
              </div>
              <div class="mt-0 pr-1">
                <font size="-2" v-b-popover.hover.top="'# txs'">{{ filteredSortedCrossTab.length }}</font>
              </div>
              <div class="mt-0 pr-1">
                <b-pagination size="sm" v-model="settings.crossTab.currentPage" @input="settingsUpdated" :total-rows="filteredSortedMainTable.length" :per-page="settings.crossTab.pageSize" style="height: 0;"></b-pagination>
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.crossTab.pageSize" @change="settingsUpdated" :options="pageSizes" v-b-popover.hover.top="'Addresses page size'"></b-form-select>
              </div>
            </div>
            <!-- <b-table small fixed striped selectable responsive hover :fields="mainTableFields" :items="pagedFilteredSortedMainTable" show-empty empty-html="Enter ERC-721 NFT collection address in the top left input field and click Retrieve" head-variant="light" class="m-0 mt-1"> -->
            <b-table small fixed striped selectable responsive hover :items="pagedFilteredSortedCrossTab" show-empty empty-html="Enter ERC-721 NFT collection address in the top left input field and click Retrieve" head-variant="light" class="m-0 mt-1">
            </b-table>
          </b-card>

          <b-card v-if="false" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <template #header>
              Owners
            </template>
            <div class="d-flex flex-wrap m-0 p-0">
              <div class="mt-0 pr-1">
                <b-form-input type="text" size="sm" v-model.trim="settings.mainCollection" @change="settingsUpdated" debounce="600" v-b-popover.hover.top="'Main collection to start from'" placeholder="0x{NFT collection address}" style="min-width: 12.0rem;"></b-form-input>
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" :disabled="sync.section != null || settings.mainCollection == null || settings.mainCollection.length == 0" @click="processIt('retrieveMainCollection')" variant="primary" v-b-popover.hover.top="'Retrieve main collection data'">Retrieve Main</b-button>
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" :disabled="sync.section != null || filteredSortedMainTable.length == 0" @click="processIt('retrieveSecondaryCollection')" variant="primary" v-b-popover.hover.top="'Retrieve secondary collection data'">Retrieve Secondary</b-button>
              </div>
              <!-- <div class="mt-0 pr-1">
                <b-form-input type="text" size="sm" v-model.trim="settings.addressTable.searchAddresses" @change="settingsUpdated" debounce="600" v-b-popover.hover.top="'Filter by partial address, name'" placeholder="🔍 address"></b-form-input>
              </div> -->
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-1" style="width: 200px;">
                <b-progress v-if="sync.section != null" height="1.5rem" :max="sync.total" show-progress :animated="sync.section != null" :variant="sync.section != null ? 'success' : 'secondary'" v-b-popover.hover.top="'Click the button on the right to stop. This process can be continued later'">
                  <b-progress-bar :value="sync.completed">
                    {{ sync.total == null ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                  </b-progress-bar>
                </b-progress>
              </div>
              <div class="ml-0 mt-1">
                <b-button v-if="sync.section != null" size="sm" @click="halt" variant="link" v-b-popover.hover.top="'Click to stop. It may take a few minutes to clean up. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <!-- <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pr-0">
                <b-button size="sm" :pressed.sync="settings.addAddresses" @click="settingsUpdated" variant="link" v-b-popover.hover.top="'Add addresses, tx hashes, Etherscan API key'"><span v-if="settings.addAddresses"><b-icon-plus-square-fill shift-v="+1" font-scale="1.0"></b-icon-plus-square-fill></span><span v-else><b-icon-plus-square shift-v="+1" font-scale="1.0"></b-icon-plus-square></span></b-button>
              </div>
              <div class="mt-0 pr-1">
                <b-button size="sm" :pressed.sync="settings.editAddresses" @click="settingsUpdated" :variant="settings.editAddresses ? 'danger' : 'link'" v-b-popover.hover.top="settings.editAddresses ? 'End editing address attributes' : 'Edit address attributes'"><b-icon-pencil shift-v="+1" font-scale="1.0"></b-icon-pencil></b-button>
              </div> -->
              <!-- <div class="mt-0 flex-grow-1">
              </div> -->
              <!-- <div class="mt-0 pr-1">
                <b-button size="sm" @click="exportAddresses" variant="link">Export</b-button>
              </div> -->
              <!-- <div class="mt-0 flex-grow-1">
              </div> -->
              <div class="mt-0 pr-1">
                <b-form-select size="sm" v-model="settings.mainTable.sortOption" @change="settingsUpdated" :options="mainTableSortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
              </div>
              <div class="mt-0 pr-1">
                <font size="-2" v-b-popover.hover.top="'# txs'">{{ filteredSortedMainTable.length }}</font>
              </div>
              <div class="mt-0 pr-1">
                <b-pagination size="sm" v-model="settings.mainTable.currentPage" @input="settingsUpdated" :total-rows="filteredSortedMainTable.length" :per-page="settings.mainTable.pageSize" style="height: 0;"></b-pagination>
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.mainTable.pageSize" @change="settingsUpdated" :options="pageSizes" v-b-popover.hover.top="'Addresses page size'"></b-form-select>
              </div>
            </div>

            <b-table small fixed striped selectable responsive hover :fields="mainTableFields" :items="pagedFilteredSortedMainTable" show-empty empty-html="Enter ERC-721 NFT collection address in the top left input field and click Retrieve" head-variant="light" class="m-0 mt-1">
              <template #head(number)="data">
                <b-dropdown size="sm" variant="link" v-b-popover.hover="'Toggle selection'">
                  <template #button-content>
                    <b-icon-check-square shift-v="+1" font-scale="0.9"></b-icon-check-square>
                  </template>
                  <b-dropdown-item href="#" @click="toggleSelectedMainTable(pagedFilteredSortedMainTable)">Toggle selection for all addresses on this page</b-dropdown-item>
                  <b-dropdown-item href="#" @click="toggleSelectedMainTable(filteredSortedMainTable)">Toggle selection for all addresses on all pages</b-dropdown-item>
                  <b-dropdown-item href="#" @click="clearSelectedMainTable()">Clear selection</b-dropdown-item>
                </b-dropdown>
              </template>
              <template #cell(number)="data">
                <b-form-checkbox size="sm" :checked="selectedMainTable[data.item.owner] ? 1 : 0" value="1" @change="toggleSelectedMainTable([data.item])">
                  {{ parseInt(data.index) + ((settings.mainTable.currentPage - 1) * settings.mainTable.pageSize) + 1 }}
                </b-form-checkbox>
              </template>
              <template #cell(owner)="data">
                {{ ensOrAddress(data.item.owner) }}
              </template>
              <template #cell(collections)="data">
                <b-avatar rounded :badge="data.item.count.toString()" variant="light" size="3.0rem" :src="mainToken.collection.image" v-b-popover.hover="mainToken.collection.name + ' x ' + data.item.count">
                </b-avatar>
                +
                <span v-for="(collection, collectionIndex) in getSecondaryCollectionsForOwner(data.item.owner)" :key="collectionIndex">
                  <b-avatar rounded :badge="collection.count.toString()" variant="light" size="3.0rem" :src="collection.collectionImage" v-b-popover.hover="collection.collectionName + ' x ' + collection.count">
                  </b-avatar>
                </span>
              </template>
            </b-table>
          </b-card>
        </b-card>
        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <b-card-text class="text-right">
            gm, and enjoy! <i>Txs</i> &copy; Bok Consulting Pty Ltd 2022.
          </b-card-text>
        </b-card no-header>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {
          coinbase: null,
          settings: {
            mainCollection: "0x31385d3520bCED94f77AaE104b406994D8F2168C", // TODO: null,
            // showImport: false, // TODO: Delete
            // addAddresses: false,
            // editAddresses: false,
            // etherscanAPIKey: null,
            addCollection: false,

            // collections: {
            //   filter: 'bored', // TODO null,
            //   max: 100,
            //   results: [],
            // },

            collections: {
              filter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'nameasc',
            },
            crossTab: {
              filter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'countdsc',
            },
            mainTable: {
              filter: null,
              currentPage: 1,
              pageSize: 100,
              sortOption: 'countdsc',
            },
          },

          searchCollections: {
            filter: null,
            results: [],
          },

          sync: {
            section: null,
            total: null,
            completed: null,
            halt: false,
          },

          collections: {},
          collectionsData: {},

          mainToken: {
            tokens: {},
            owners: {},
            collection: {
              name: null,
              image: null,
              slug: null,
            }
          },
          secondaryData: {},

          ensMap: {},
          selectedCollections: {},
          selectedMainTable: {},

          collectionsSortOptions: [
            { value: 'nameasc', text: '▲ Name' },
            { value: 'namedsc', text: '▼ Name' },
          ],
          mainTableSortOptions: [
            { value: 'countasc', text: '▲ Token Count' },
            { value: 'countdsc', text: '▼ Token Count' },
          ],
          pageSizes: [
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 25, text: '25' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
            { value: 500, text: '500' },
            { value: 1000, text: '1k' },
            { value: 2500, text: '2.5k' },
            { value: 10000, text: '10k' },
          ],
          // Id Name Slug Image Banner Token Count
          searchCollectionsFields: [
            { key: 'action', label: 'Action', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'collection', label: 'Collection', sortable: false, thStyle: 'width: 90%;', tdClass: 'text-truncate' },
          ],
          collectionsFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'collection', label: 'Collection', sortable: false, thStyle: 'width: 95%;', tdClass: 'text-truncate' },
          ],
          mainTableFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'owner', label: 'Owner', sortable: false, thStyle: 'width: 30%;', tdClass: 'text-truncate' },
            { key: 'collections', label: 'Collections', sortable: false, thStyle: 'width: 65%;', tdClass: 'text-truncate' },
          ],
          db: {
            name: "nftowner089",
            version: 1,
            schemaDefinition: {
              cache: '&objectName',
            },
            updated: null,
          },
        },

        // --- COMPUTED ---
        computed: {
          filteredCollections() {
            const results = [];
            for (const [contract, item] of Object.entries(this.collections)) {
              results.push({
                contract,
                name: item.name,
                slug: item.slug,
                image: item.image,
                volume: item.volume,
                tokens: item.tokens,
                owners: item.owners,
                updated: item.updated,
              });
            }
            return results;
          },
          filteredSortedCollections() {
            let results = this.filteredCollections;
            // if (this.settings.mainTable.sortOption == 'countasc') {
            //   results.sort((a, b) => a.count - b.count);
            // } else if (this.settings.mainTable.sortOption == 'countdsc') {
            //   results.sort((a, b) => b.count - a.count);
            // }
            return results;
          },
          pagedFilteredSortedCollections() {
            return this.filteredSortedCollections.slice((this.settings.collections.currentPage - 1) * this.settings.collections.pageSize, this.settings.collections.currentPage * this.settings.collections.pageSize);
          },
          filteredCrossTab() {
            const order = [
              "0x31385d3520bced94f77aae104b406994d8f2168c",
              "0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb",
              "0x282bdd42f4eb70e7a9d9f40c8fea0825b7f68c5d"
            ];
            console.log("filteredCrossTab: " + JSON.stringify(order));

            const table = {};
            for (const contractIndex in order) {
              const contract = order[contractIndex];
              const collection = this.collections[contract];
              if (collection) {
                const tokens = collection.tokens;
                const owners = collection.owners;
                console.log(contractIndex + ": " + collection.name);
                let i = 0;
                for (const [owner, tokenIds] of Object.entries(owners)) {
                  if (!(owner in table)) {
                    table[owner] = {};
                  }
                  table[owner][contract] = tokenIds;
                  // if (i < 10) {
                  //   console.log("  " + owner + " " + JSON.stringify(tokenIds));
                  // }
                  i++;
                }
              }
            }
            // console.log("Object.keys(table): " + JSON.stringify(Object.keys(table), null, 2));
            // console.log("table: " + JSON.stringify(table, null, 2));

            const results = [];
            let i = 0;
            for (const [owner, row] of Object.entries(table)) {
              const record = {};
              record['owner'] = owner;

              for (const contractIndex in order) {
                const contract = order[contractIndex];
                record['c' + contractIndex.toString()] = row[contract] || null;
              }
              // results.push({
              //   owner,
              // });
              results.push(record);
              // if (i < 10) {
                console.log("  " + owner + " " + JSON.stringify(row, null, 2));
              // }
              i++;
            }

            // for (const [contract, item] of Object.entries(this.collections)) {
            //   results.push({
            //     contract,
            //     name: item.name,
            //     slug: item.slug,
            //     image: item.image,
            //     volume: item.volume,
            //     tokens: Object.keys(item.tokens).length,
            //     owners: Object.keys(item.owners).length,
            //     updated: item.updated,
            //   });
            // }
            // console.log("filteredCrossTab: " + JSON.stringify(results.slice(0, 10)));
            return results;
          },
          filteredSortedCrossTab() {
            let results = this.filteredCrossTab;
            // if (this.settings.mainTable.sortOption == 'countasc') {
            //   results.sort((a, b) => a.count - b.count);
            // } else if (this.settings.mainTable.sortOption == 'countdsc') {
            //   results.sort((a, b) => b.count - a.count);
            // }
            return results;
          },
          pagedFilteredSortedCrossTab() {
            return this.filteredSortedCrossTab.slice((this.settings.crossTab.currentPage - 1) * this.settings.crossTab.pageSize, this.settings.crossTab.currentPage * this.settings.crossTab.pageSize);
          },
          filteredMainTable() {
            const results = [];
            for (const [owner, data] of Object.entries(this.mainToken.owners)) {
              results.push({ owner, count: data.length });
            }
            return results;
          },
          filteredSortedMainTable() {
            let results = this.filteredMainTable;
            if (this.settings.mainTable.sortOption == 'countasc') {
              results.sort((a, b) => a.count - b.count);
            } else if (this.settings.mainTable.sortOption == 'countdsc') {
              results.sort((a, b) => b.count - a.count);
            }
            return results;
          },
          pagedFilteredSortedMainTable() {
            return this.filteredSortedMainTable.slice((this.settings.mainTable.currentPage - 1) * this.settings.mainTable.pageSize, this.settings.mainTable.currentPage * this.settings.mainTable.pageSize);
          },
        },

        // --- METHODS ---
        methods: {
          getSecondaryCollectionsForOwner(owner) {
            const results = [];
            if (owner in this.secondaryData) {
              const mainContract = this.settings.mainCollection.toLowerCase();
              for (const [contract, item] of Object.entries(this.secondaryData[owner])) {
                // if (contract != mainContract) {
                  results.push({ contract, collectionName: item.collectionName, collectionImage: item.collectionImage, count: Object.keys(item.tokens).length });
                // }
              }
              results.sort((a, b) => {
                if (a.contract == mainContract) {
                  return 1;
                } else if (b.contract == mainContract) {
                  return -1;
                } else {
                  return b.count - a.count;
                }
              });
            }
            // if (owner == "0xc3b5284b2c0cfa1871a6ac63b6d6ee43c08bdc79") {
            //   console.log(JSON.stringify(results));
            // }
            return results;
          },
          async halt() {
            this.sync.halt = true;
            console.log("this.sync.halt: " + this.sync.halt);
          },
          commify(n) {
            if (n != null) {
              return ethers.utils.commify(n);
            }
            return null;
          },
          formatTimestamp(ts) {
            if (ts != null) {
              return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
            }
            return null;
          },
          formatETH(e) {
            try {
              return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(9) : null;
            } catch (err) {
            }
            return e.toFixed(9);
          },
          ensOrAddress(address, length = 0) {
            if (this.ensMap) {
              if (address in this.ensMap) {
                return length == 0 ? this.ensMap[address] : this.ensMap[address].substring(0, length);
              }
            }
            return address == null ? null : (length == 0 ? address : address.substring(0, length));
          },
          toggleSelectedCollections(items) {
            console.log("toggleSelectedCollections: " + JSON.stringify(items));
            let someFalse = false;
            let someTrue = false;
            for (const item of items) {
              if (this.selectedCollections[item.contract]) {
                someTrue = true;
              } else {
                someFalse = true;
              }
            }
            for (const item of items) {
              if (!(someTrue && !someFalse)) {
                Vue.set(this.selectedCollections, item.contract, true);
              } else {
                Vue.delete(this.selectedCollections, item.contract);
              }
            }
            localStorage.selectedCollections = JSON.stringify(this.selectedCollections);
            console.log("selectedCollections: " + JSON.stringify(this.selectedCollections, null, 2));
          },
          clearSelectedCollections() {
            console.log("clearSelectedCollections");
            this.selectedCollections = {};
            localStorage.selectedCollections = JSON.stringify(this.selectedCollections);
          },
          toggleSelectedMainTable(items) {
            let someFalse = false;
            let someTrue = false;
            for (const item of items) {
              if (this.selectedMainTable[item.owner]) {
                someTrue = true;
              } else {
                someFalse = true;
              }
            }
            for (const item of items) {
              if (!(someTrue && !someFalse)) {
                Vue.set(this.selectedMainTable, item.owner, true);
              } else {
                Vue.delete(this.selectedMainTable, item.owner);
              }
            }
            localStorage.selectedMainTable = JSON.stringify(this.selectedMainTable);
          },
          clearSelectedMainTable() {
            this.selectedMainTable = {};
            localStorage.selectedMainTable = JSON.stringify(this.selectedMainTable);
          },
          settingsUpdated() {
            console.log("settingsUpdated: " + JSON.stringify(this.settings, null, 2));
            localStorage.settings = JSON.stringify(this.settings);
          },
          async addressesUpdated() {
            // console.log("addressesUpdated");
            // localStorage.txsPeriod = this.settings.txs.period;
            // console.log("addressesUpdated: " + JSON.stringify(this.addresses, null, 2));
            const db0 = new Dexie(this.db.name);
            db0.version(this.db.version).stores(this.db.schemaDefinition);
            await db0.cache.put({ objectName: 'addresses', object: this.addresses }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
            db0.close();
          },
          exportTxHashes() {
            console.log("exportTxHashes");
            var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.txHashes));
            var link = document.createElement("a");
            link.setAttribute("href", dataStr);
            link.setAttribute("download", "txhashes.json");
            document.body.appendChild(link); // Required for FF
            link.click();
          },
          exportAddresses() {
            console.log("exportAddresses");
            var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.addresses));
            var link = document.createElement("a");
            link.setAttribute("href", dataStr);
            link.setAttribute("download", "addresses.json");
            document.body.appendChild(link); // Required for FF
            link.click();
          },
          copyToClipboard(str) {
            // https://github.com/30-seconds/30-seconds-of-code/blob/master/snippets/copyToClipboard.md
            const el = document.createElement('textarea');
            el.value = str;
            el.setAttribute('readonly', '');
            el.style.position = 'absolute';
            el.style.left = '-9999px';
            document.body.appendChild(el);
            const selected =
              document.getSelection().rangeCount > 0
                ? document.getSelection().getRangeAt(0)
                : false;
            el.select();
            document.execCommand('copy');
            document.body.removeChild(el);
            if (selected) {
              document.getSelection().removeAllRanges();
              document.getSelection().addRange(selected);
            }
          },
          async addCollection(collection) {
            console.log("addCollection: " + JSON.stringify(collection));
            Vue.set(this.collections, collection.contract, {
              name: collection.name,
              slug: collection.slug,
              image: collection.image,
              tokenCount: collection.tokenCount,
              onSaleCount: collection.onSaleCount,
              volume: collection.volume,
              tokens: {},
              owners: {},
              updated: null,
            });
            console.log(JSON.stringify(this.collections, null, 2));
            const db0 = new Dexie(this.db.name);
            db0.version(this.db.version).stores(this.db.schemaDefinition);
            await db0.cache.put({ objectName: 'collections', object: this.collections }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
            db0.close();
          },
          async deleteCollections() {
            console.log("deleteCollections");
            for (const contract of Object.keys(this.selectedCollections)) {
              console.log("Deleting: " + contract);
              Vue.delete(this.collections, contract);
            }
            this.selectedCollections = {};
            localStorage.selectedCollections = JSON.stringify(this.selectedCollections);
            const db0 = new Dexie(this.db.name);
            db0.version(this.db.version).stores(this.db.schemaDefinition);
            await db0.cache.put({ objectName: 'collections', object: this.collections }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
            db0.close();
          },
          async doSearchCollections(filter) {
            console.log("doSearchCollections - filter: " + JSON.stringify(filter));
            this.settingsUpdated();
            let continuation = null;
            const results = [];
            // if (this.searchCollections.filter != null && this.searchCollections.filter.length > 0) {
              do {
                // https://api.reservoir.tools/collections/v5?name=test&includeTopBid=false&sortBy=allTimeVolume&limit=20
                let url = "https://api.reservoir.tools/collections/v5" +
                  ((filter != null && filter.length > 0) ? "?name=" + filter + '&includeTopBid=false&sortBy=allTimeVolume&limit=20' : ''); // +
                  // "&limit=50" +
                  // (continuation != null ? "&continuation=" + continuation : '');
                console.log("url: " + url);
                const data = await fetch(url)
                  .then(handleErrors)
                  .then(response => response.json())
                  .catch(function(error) {
                     console.log("ERROR - updateCollection: " + error);
                     // state.sync.error = true;
                     return [];
                  });
                continuation = data.continuation;
                // console.log(JSON.stringify(data, null, 2));
                if (data && data.collections) {
                  for (const collectionData of data.collections) {
                    console.log(JSON.stringify(collectionData, null, 2));
                    // const collectionId = collectionData.id;
                    const contract = collectionData.id;
                    const name = collectionData.name;
                    const slug = collectionData.slug;
                    const image = collectionData.image;
                    const tokenCount = collectionData.tokenCount;
                    const onSaleCount = collectionData.onSaleCount;
                    const volume = collectionData.volume;
                    const openseaVerificationStatus = collectionData.openseaVerificationStatus;
                    if (!(contract in this.collections)) {
                      results.push({ contract, name, slug, image, volume, openseaVerificationStatus });
                    }
                  }
                }
              } while (continuation != null && results.length < this.searchCollections.max /*&& !state.halt && !state.sync.error */);
              results.sort((a, b) => b.allTimeVolume - a.allTimeVolume);
            // }
            Vue.set(this.searchCollections, 'results', results);
            console.log("this.searchCollections.results: " + JSON.stringify(this.searchCollections.results, null, 2));
          },
          async processIt(action, parameters = null) {
            console.log("processIt - action: " + action + ", parameters: " + parameters);
            let connected = true;
            if (!window.ethereum) {
              connected = false;
            } else {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                connected = window.ethereum.isConnected();
              } catch (e) {
                console.log("window.ethereum.request error: " + e.message);
                connected = false;
              }
            }
            if (!connected) {
              alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
            } else {
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              const signer = provider.getSigner();
              const ensReverseRecordsContract = new ethers.Contract(ENSREVERSERECORDSADDRESS, ENSREVERSERECORDSABI, provider);
              const erc721Helper = new ethers.Contract(ERC721HELPERADDRESS, ERC721HELPERABI, provider);
              this.coinbase = await signer.getAddress();
              localStorage.coinbase = this.coinbase;
              const network = await provider.getNetwork();
              const block = await provider.getBlock("latest");
              const blockNumber = block.number;
              const timestamp = block.timestamp;
              const ENSOWNERBATCHSIZE = 100; // 500 fails occassionally

              const db0 = new Dexie(this.db.name);
              db0.version(this.db.version).stores(this.db.schemaDefinition);

              if (action == "retrieveMainCollection") {
                console.log("retrieveMainCollection");

                let continuation = null;
                this.sync.completed = 0;
                this.sync.total = null;
                this.sync.section = "Main collection";
                const mainTokens = {};
                this.mainToken.collection.name = null;
                do {
                  let url = "https://api.reservoir.tools/tokens/v5?contract=" + this.settings.mainCollection + "&limit=100" +
                    (continuation != null ? "&continuation=" + continuation : '');
                  console.log("url: " + url);
                  const data = await fetch(url)
                    .then(handleErrors)
                    .then(response => response.json())
                    .catch(function(error) {
                       console.log("ERROR - updateCollection: " + error);
                       // state.sync.error = true;
                       return [];
                    });
                  continuation = data.continuation;
                  if (data && data.tokens) {
                    for (const tokenData of data.tokens) {
                      const token = tokenData.token;
                      mainTokens[token.tokenId] = {
                        owner: token.owner,
                        image: token.image,
                      };
                      if (this.mainToken.collection.name == null) {
                        this.mainToken.collection.name = token.collection.name;
                        this.mainToken.collection.image = token.collection.image;
                        this.mainToken.collection.slug = token.collection.slug;
                      }
                    }
                  }
                  this.sync.completed = Object.keys(mainTokens).length;
                  await delay(500); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms
                } while (continuation != null /*&& !state.halt && !state.sync.error */);

                const mainOwners = {};
                for (const [tokenId, data] of Object.entries(mainTokens)) {
                  if (!(data.owner in mainOwners)) {
                    mainOwners[data.owner] = [];
                  }
                  mainOwners[data.owner].push(tokenId);
                }
                // console.log(JSON.stringify(mainOwners, null, 2));

                this.sync.completed = 0;
                const addresses = Object.keys(mainOwners);
                this.sync.total = addresses.length;
                this.sync.section = "ENS Names";
                const ensMap = {};
                for (let i = 0; i < addresses.length & !this.sync.halt; i += ENSOWNERBATCHSIZE) {
                  const batch = addresses.slice(i, parseInt(i) + ENSOWNERBATCHSIZE);
                  const allnames = await ensReverseRecordsContract.getNames(batch);
                  for (let j = 0; j < batch.length; j++) {
                    const address = batch[j];
                    const name = allnames[j];
                    ensMap[address] = name != null && name.length > 0 ? name : address;
                    // const normalized = normalize(address);
                  }
                  this.sync.completed = parseInt(this.sync.completed) + batch.length;
                }
                this.ensMap = ensMap;
                await db0.cache.put({ objectName: 'ensMap', object: ensMap }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                this.mainToken.tokens = mainTokens;
                this.mainToken.owners = mainOwners;
                await db0.cache.put({ objectName: 'mainToken', object: this.mainToken }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                this.secondaryData = {};
                await db0.cache.put({ objectName: 'secondaryData', object: this.secondaryData }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                this.sync.section = null;
              }

              if (action == "syncCollections") {
                console.log("syncCollections");
                let contracts = [];
                if (Object.keys(this.selectedCollections).length > 0) {
                  contracts = Object.keys(this.selectedCollections);
                } else {
                  for (const record of this.filteredSortedCollections) {
                    if (!(record.contract in this.secondaryData)) {
                      contracts.push(record.contract);
                    }
                  }
                }
                console.log("contracts: " + JSON.stringify(contracts));
                for (let contract of contracts) {
                  console.log("Processing: " + contract + " " + JSON.stringify(this.collections[contract]));

                  let continuation = null;
                  this.sync.completed = 0;
                  this.sync.total = null;
                  this.sync.section = this.collections[contract].name.substring(0, 24);
                  const tokens = {};
                  // this.mainToken.collection.name = null;
                  do {
                    let url = "https://api.reservoir.tools/tokens/v5?contract=" + contract + "&includeAttributes=false&limit=100" +
                      (continuation != null ? "&continuation=" + continuation : '');
                    console.log("url: " + url);
                    const data = await fetch(url)
                      .then(handleErrors)
                      .then(response => response.json())
                      .catch(function(error) {
                         console.log("ERROR - updateCollection: " + error);
                         // state.sync.error = true;
                         return [];
                      });
                    continuation = data.continuation;
                    // console.log(JSON.stringify(data, null, 2));
                    if (data && data.tokens) {
                      for (const tokenData of data.tokens) {
                        const token = tokenData.token;
                        tokens[token.tokenId] = {
                          owner: token.owner,
                          image: token.image,
                        };
                        // if (this.mainToken.collection.name == null) {
                        //   this.mainToken.collection.name = token.collection.name;
                        //   this.mainToken.collection.image = token.collection.image;
                        //   this.mainToken.collection.slug = token.collection.slug;
                        // }
                      }
                    }
                    this.sync.completed = Object.keys(tokens).length;
                    await delay(500); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms
                  } while (continuation != null /*&& !state.halt && !state.sync.error */);
                  // console.log("tokens: " + JSON.stringify(tokens, null, 2));
                  Vue.set(this.collections[contract], 'tokens', tokens);

                  const owners = {};
                  for (const [tokenId, data] of Object.entries(tokens)) {
                    if (!(data.owner in owners)) {
                      owners[data.owner] = [];
                    }
                    owners[data.owner].push(tokenId);
                  }
                  // console.log("owners: " + JSON.stringify(owners, null, 2));
                  Vue.set(this.collections[contract], 'owners', owners);
                  Vue.set(this.collections[contract], 'updated', timestamp);
                }
                // console.log("collections: " + JSON.stringify(this.collections, null, 2));
                await db0.cache.put({ objectName: 'collections', object: this.collections }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
              }


              if (action == "retrieveSecondaryCollection") {
                console.log("retrieveSecondaryCollection");
                let owners = [];
                if (Object.keys(this.selectedMainTable).length > 0) {
                  owners = Object.keys(this.selectedMainTable);
                } else {
                  for (const record of this.filteredSortedMainTable) {
                    if (!(record.owner in this.secondaryData)) {
                      owners.push(record.owner);
                    }
                  }
                }
                console.log("owners: " + JSON.stringify(owners));

                this.sync.completed = 0;
                this.sync.total = owners.count;
                this.sync.section = "Secondary collection";
                for (let owner of owners) {
                  console.log("Processing: " + owner);
                  Vue.set(this.secondaryData, owner, {});
                  let stop = false;
                  const LIMIT = 100;
                  const MAXLIMIT = 10000;
                  for (let offset = 0; offset < MAXLIMIT && !stop; offset = parseInt(offset) + LIMIT) {
                    let url = "https://api.reservoir.tools/users/" + owner + "/tokens/v5?sortBy=acquiredAt&sortDirection=desc&offset=" + offset + "&limit=" + LIMIT + "&includeTopBid=false";
                    console.log("url: " + url);
                    const data = await fetch(url)
                      .then(handleErrors)
                      .then(response => response.json())
                      .catch(function(error) {
                         console.log("ERROR - updateCollection: " + error);
                         // state.sync.error = true;
                         return [];
                      });
                    // console.log(JSON.stringify(data.tokens, null, 2));
                    if (data && data.tokens && data.tokens.length > 0) {
                      // console.log(JSON.stringify(data.tokens, null, 2));
                      // const contract = data.tokens

                      for (const tokenData of data.tokens) {
                        // console.log(JSON.stringify(tokenData, null, 2));
                        // if (!(owner in this.secondaryData)) {
                        //   Vue.set(this.secondaryData, owner, {});
                        // }
                        const contract = tokenData.token.contract;
                        const tokenId = tokenData.token.tokenId;
                        const name = tokenData.token.name;
                        const image = tokenData.token.image;
                        const collectionName = tokenData.token.collection.name;
                        const collectionImage = tokenData.token.collection.imageUrl;
                        if (!(contract in this.secondaryData[owner])) {
                          Vue.set(this.secondaryData[owner], contract, {
                            collectionName,
                            collectionImage,
                            tokens: {},
                          });
                        }
                        Vue.set(this.secondaryData[owner][contract].tokens, tokenId, { tokenId, name, image });
                      }
                    } else {
                      stop = true;
                    }
                    await delay(750); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms
                  }
                  await delay(1000); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms

                  this.sync.completed = parseInt(this.sync.completed) + 1;
                  if (this.sync.halt) {
                    break;
                  }
                }
                // console.log("secondaryData: " + JSON.stringify(this.secondaryData, null, 2));
                await db0.cache.put({ objectName: 'secondaryData', object: this.secondaryData }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
              }

              db0.close();
              this.sync.section = null;
              this.sync.halt = false;
            }
          },
        },

        // --- MOUNTED ---
        mounted() {
          if ('coinbase' in localStorage) {
            this.coinbase = localStorage.coinbase;
          }
          if ('selectedCollections' in localStorage) {
            this.selectedCollections = JSON.parse(localStorage.selectedCollections);
            console.log("mounted - selectedCollections: " + JSON.stringify(this.selectedCollections, null, 2));
          }
          if ('selectedMainTable' in localStorage) {
            this.selectedMainTable = JSON.parse(localStorage.selectedMainTable);
          }
          // if ('settings' in localStorage) {
          //   // console.log("mounted - before - this.settings: " + JSON.stringify(this.settings, null, 2));
          //   // console.log("mounted - before - localStorage.settings: " + localStorage.settings);
          //   this.settings = { ...this.settings, ...JSON.parse(localStorage.settings) };
          //
          //   if (this.settings.txs.currentPage > 1) {
          //     this.settings.txs.currentPage = 1;
          //   }
          //   if (this.settings.addressTable.currentPage > 1) {
          //     this.settings.addressTable.currentPage = 1;
          //   }
          //   console.log("mounted - after: " + JSON.stringify(this.settings, null, 2));
          // }
          (async() => {
            const db0 = new Dexie(this.db.name);
            db0.version(this.db.version).stores(this.db.schemaDefinition);
            const collections = await db0.cache.where("objectName").equals('collections').toArray();
            if (collections.length == 1) {
              this.collections = collections[0].object;
              // console.log("mounted - collections: " + JSON.stringify(this.collections, null, 2));
            }
            const mainToken = await db0.cache.where("objectName").equals('mainToken').toArray();
            if (mainToken.length == 1) {
              this.mainToken = mainToken[0].object;
              // console.log("mounted - mainToken.owners: " + JSON.stringify(this.mainToken.owners, null, 2));
            }
            const ensMap = await db0.cache.where("objectName").equals('ensMap').toArray();
            if (ensMap.length == 1) {
              this.ensMap = ensMap[0].object;
              // console.log("mounted - ensMap: " + JSON.stringify(this.ensMap, null, 2));
            }
            const secondaryData = await db0.cache.where("objectName").equals('secondaryData').toArray();
            if (secondaryData.length == 1) {
              this.secondaryData = secondaryData[0].object;
              // console.log("mounted - secondaryData: " + JSON.stringify(this.secondaryData, null, 2));
            }
            db0.close();
          })();
        },
      })
    </script>
  </body>
</html>
